
Syscall API(SystemCall)
리다이렉션 - 셀에서 제공하는 기능 - 실행 명령어 기준 표준 스트림 변경

표준출력 리다이렉션
명령어 > 파일명
	
-출력 리다이렉션의 특성..
	중요한 내용이 저장되어있는 상태에서 오류가 발생하면 기존의 파일 내용이 다 날라가므로 조심
	
	기존의 타입이 존재할 경우 날라감.

		
		
		
		
표준입력출력을 만들 수도 있다 .mkfifo myfifo

한쪽에서 입력 cat < myfifo
한쪽에서 출력 cat > myfifo 를 하여 서로 받아 볼 수 있다.

리눅스의 환경변수는 관례적으로 대문자로 쓴다.

 - 중괄호를 이용한 다중출력
 
linux@ubuntu:~$ echo {1,2,3,4,5,6,7,8}
1 2 3 4 5 6 7 8

linux@ubuntu:~$ touch file.{1,2,3,4,5,6,7,8}
file.1 file.2 file.3 file.4 file.5 file.6 file.7 file.8

중괄호 확장을 통해 파일 생성.
중괄호 내부 변수들에는 공백이 존재하면안된다.

linux@ubuntu:~/0610$ echo file.{0..9}  순차적으로 올라가는 관계라면 생략(..) 표시를 통해 생성 하여도된다.

두개를 연달아 쓰는것도 가능.
linux@ubuntu:~/0610$ echo a.{0..9}{A..F} 
a.0A a.0B a.0C a.0D a.0E a.0F a.1A a.1B a.1C a.1D a.1E a.1F a.2A 
a.2B a.2C a.2D a.2E a.2F a.3A a.3B a.3C a.3D a.3E a.3F a.4A a.4B
a.4C a.4D a.4E a.4F a.5A a.5B a.5C a.5D a.5E a.5F a.6A a.6B a.6C 
a.6D a.6E a.6F a.7A a.7B a.7C a.7D a.7E a.7F a.8A a.8B a.8C a.8D 
a.8E a.8F a.9A a.9B a.9C a.9D a.9E a.9F

포함의 관계 표시가능
linux@ubuntu:~/0610$ echo _{A{1,2},B{3,4}}_
_A1_ _A2_ _B3_ _B4_


linux@ubuntu:~/0610$ mkdir 20{00..11}_{00..12}
2000년 1월부터 2011년 12월까지 출력

2000_01  2001_07  2003_01  2004_07  2006_01  2007_07  2009_01  2010_07
2000_02  2001_08  2003_02  2004_08  2006_02  2007_08  2009_02  2010_08
2000_03  2001_09  2003_03  2004_09  2006_03  2007_09  2009_03  2010_09
2000_04  2001_10  2003_04  2004_10  2006_04  2007_10  2009_04  2010_10
2000_05  2001_11  2003_05  2004_11  2006_05  2007_11  2009_05  2010_11
2000_06  2001_12  2003_06  2004_12  2006_06  2007_12  2009_06  2010_12
2000_07  2002_01  2003_07  2005_01  2006_07  2008_01  2009_07  2011_01
2000_08  2002_02  2003_08  2005_02  2006_08  2008_02  2009_08  2011_02
2000_09  2002_03  2003_09  2005_03  2006_09  2008_03  2009_09  2011_03
2000_10  2002_04  2003_10  2005_04  2006_10  2008_04  2009_10  2011_04
2000_11  2002_05  2003_11  2005_05  2006_11  2008_05  2009_11  2011_05
2000_12  2002_06  2003_12  2005_06  2006_12  2008_06  2009_12  2011_06
2001_01  2002_07  2004_01  2005_07  2007_01  2008_07  2010_01  2011_07
2001_02  2002_08  2004_02  2005_08  2007_02  2008_08  2010_02  2011_08
2001_03  2002_09  2004_03  2005_09  2007_03  2008_09  2010_03  2011_09
2001_04  2002_10  2004_04  2005_10  2007_04  2008_10  2010_04  2011_10
2001_05  2002_11  2004_05  2005_11  2007_05  2008_11  2010_05  2011_11
2001_06  2002_12  2004_06  2005_12  2007_06  2008_12  2010_06  2011_12


Shell은 불필요한 Token을 알아서 없앤다.

linux@ubuntu:~/0610$ echo hello,                             world
#공백문자를 많이 썻지만
hello, world
#출력되는 공백은 하나.



linux@ubuntu:~/0610$ echo "hello,                             world"
hello,                             world
#이중부호를 사용하면 그대로 문자로 해석/출력한다.
#인용부호도 마찬가지.
	다만 둘의 차이 
		- 인용부호안의 모든 문자를 확장이나 치환 없이 문자 그대로 처리 할 때 사용

	공백과 탭을 그대로 출력.
	와일드카드의 동작이 되지 않는다.
	
linux@ubuntu:~/0610$ echo "*"
* #동작하지않는 와일드카드

명령어 치환은 그대로 동작('', $())
	linux@ubuntu:~/0610$ echo "`date`"
	Tue Jun  9 22:35:01 PDT 2020

매개변수 치환 또는 확장은 그대로 동작
	linux@ubuntu:~/0610$ echo "$HOME"
	/home/linux

백슬래시는 그대로 동작
	linux@ubuntu:~/0610$ echo "\$HOME"
	$HOME
	백슬래시가 재역할을 하여 HOME directory path가 나오지 않았다.

	백슬래시 사용용도
		linux@ubuntu:~/0610$ echo It\'s different
		It's different
	인용부호를 그대로 출력하게 만들기.'
	등등 기능문자를 출력하기위해 사용 혹은 이중부호

	#탈출문자 사용 할 때도 사용 \n, \t 등등
	
	
	linux@ubuntu:~/0610$ echo -e "hello\nworld"
	#제어 문자를 가진 문자열을 확장문자열
	hello
	world
	
	
linux@ubuntu:~/0610$ echo "$(cal)" == cal
     June 2020
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30

linux@ubuntu:~/0610$ touch hello, world.txt
#공백문자 또한 token이기 때문에 그대로 인식하게하려면 인용부호를 사용해주어야한다.
-rw-rw-r--  1 linux linux    0 Jun  9 23:23 hello,
-rw-rw-r--  1 linux linux    0 Jun  9 23:23 world.txt


linux@ubuntu:~$ echo .[^.]*


리눅스 
	- 일반 			: /home/idDiretory
	- 관리자(root)	: /root (관리자용 홈디렉토리)
	
linux@ubuntu:~$ find / -name '*.c' 2> /dev/null


패턴에서 메타문자 또는 와일드 카드 사용 시 전처리에 의해 확장.
	확장되지 않게 
	
	linux@ubuntu:/$ find . -name '*.txt'
감싸주자.


비어있는 디렉토리는 검색이 안된다. 
empty : 크기가 0인 파일이나 비어있는 디렉터리를 검색하는 옵션.


연산자
	-and, a : 연산자를 기준으로 양쪽의 조건이 참 일때 검색을 수행
			기본적으로 아무런 연산자를 사용하지 않으면 이 연산자가 적용된다.
			
find . -name '*.txt' - and -type f -and -empty
find . -name '*.txt' - a -type f -a -empty
find . -name '*.txt'  -type f -empty


	확장자가 .c이거나 .cpp인 파일을 검색하고 싶을 때.

-not, -! 단항연산 연산자의 다음으로 오는 조건이 거짓인 경우 검색수행.
확장자가 .c인 일반 파일에 대하여 크기가 0이 아닌 파일 검색 시.
find . - name '*.c' -and -type f -and -not -empty
fid . -name '*.c' -type f -! -empty

-() : 표현식을 하나로 묶어 처리/ 가독성 상향
앞뒤에 공백이 있어야하고 전처리 되지 않도록 백슬래시를 사용해야한다.


action : find 명령에 대한 결과를 어떻게 처리할 것인가에 대하여 결정.
	-정의된 액션
	-사용자 액션

find . == find . print


delete : 검색된 결과 삭제
	find . -name '*.txt' -type f
	
exec 명령어 : 검색된 결과에 대하여 지정된 명령을 실행하는 액션
	-exec {};

linux@ubuntu:~/mysub$ find . -type d -and -empty -and -exec rmdir \{} \;

linux@ubuntu:~/mysub$ find . -type d -and -empty -and -exec rmdir '{}' ';'
#find로 검색된 내용을 중괄호로 넘긴다.
#그러나 검색된 내용이 수천, 수만가지라면 rmdir를 수만번해야한다.

#이러한 반복되는 find 액션을 줄이기 위해서 
	#find . -name '*.c' -empty -exec rm \{} \+
								# +기호가  결과값을 {}에 다 밀어넣고 한꺼번에 rm을 수행하게된다.
								#명령어를 한번만 실행하게된다.
								
해당 구문은 디렉토리 내부에 디렉토리가 존재하지 않는다는 오류가 뜬다.



linux@ubuntu:~/mysub$ find . -type d -empty -prune -exec rmdir \{} \;
그러므로 find -prune의 옵션을 주어서

지정한 이름이 디렉토리 일때 그 이하 서브디렉토리는 탐색하지 않는다
라고 명시적으로 설정해준다.

prune은 디렉토리가 없다면 참을 반환한다.

'option'	 : 검색 범위설정
	-maxdepth level : 테스트와 액션을 실행할 때 디렉터리의 최대 깊이를 숫자로 지정
	find -maxdepth 1  한 단계 밑 디렉터리 깊이까지 find


#------------------------------------------#
$ echo $(cal)
June 2020 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8  9 10 11 12 13 14 15 16 17 18 19
20 21 22 23 24 25 26 27 28 29 30

Shell은 2개 이상의 공백과 탭 그리고 개행을 모두 불필요하다고 생각하여 제거한다.

$ echo "$(cal)"
     June 2020
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30

#큰 따옴표를 이용하면 2개 이상의 공백과 탭 그리고 개행을 그대로 유지하기 때문

현재 디렉터리(.)랑 상위 디렉터리(..)를 제외한 숨김 파일과 디렉터리 출력
echo .??*

??는 특수문자를 포함하지 않는다 숫자와 문자에 대해서만 출력한다.
그렇지만 .a .b 와같은 한자리 숫자 디렉터리 및 파일은 출력하지 못한다.

-> $ echo .[^.]*
#.다음으로 오는 글자는 .을 제외한 나머지 최종 폼 -> .* 의 모습이된다.
#.은 .*에 포함되지 않고 .뒤에 오는 .은 제외 시켰으므로 
# 최종적으로 현재 디렉터리와 상위 디렉터리는 출력되지 않는다.



